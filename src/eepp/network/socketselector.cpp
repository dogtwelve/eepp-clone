#include <eepp/network/socketselector.hpp>
#include <eepp/network/socket.hpp>
#include <eepp/network/platform/platformimpl.hpp>
#include <utility>

#ifdef _MSC_VER
	#pragma warning(disable : 4127) // "conditional expression is constant" generated by the FD_SET macro
#endif

namespace EE { namespace Network {

struct SocketSelector::SocketSelectorImpl {
	fd_set AllSockets;   ///< Set containing all the sockets handles
	fd_set SocketsReady; ///< Set containing handles of the sockets that are ready
	int	MaxSocket;	///< Maximum socket handle
};

SocketSelector::SocketSelector() :
	mImpl( eeNew( SocketSelectorImpl, () ) )
{
	Clear();
}

SocketSelector::SocketSelector(const SocketSelector& copy) :
	mImpl( eeNew( SocketSelectorImpl, (*copy.mImpl) ) )
{
}

SocketSelector::~SocketSelector() {
	eeSAFE_DELETE( mImpl );
}

void SocketSelector::Add(Socket& socket) {
	SocketHandle handle = socket.GetHandle();

	if (handle != Private::SocketImpl::InvalidSocket()) {
		FD_SET(handle, &mImpl->AllSockets);

		int size = static_cast<int>(handle);
		if (size > mImpl->MaxSocket)
			mImpl->MaxSocket = size;
	}
}

void SocketSelector::Remove(Socket& socket) {
	FD_CLR(socket.GetHandle(), &mImpl->AllSockets);
	FD_CLR(socket.GetHandle(), &mImpl->SocketsReady);
}

void SocketSelector::Clear() {
	FD_ZERO(&mImpl->AllSockets);
	FD_ZERO(&mImpl->SocketsReady);

	mImpl->MaxSocket = 0;
}

bool SocketSelector::Wait(Time timeout) {
	// Setup the timeout
	timeval time;
	time.tv_sec  = static_cast<long>(timeout.AsMicroseconds() / 1000000);
	time.tv_usec = static_cast<long>(timeout.AsMicroseconds() % 1000000);

	// Initialize the set that will contain the sockets that are ready
	mImpl->SocketsReady = mImpl->AllSockets;

	// Wait until one of the sockets is ready for reading, or timeout is reached
	int count = select(mImpl->MaxSocket + 1, &mImpl->SocketsReady, NULL, NULL, timeout != Time::Zero ? &time : NULL);

	return count > 0;
}

bool SocketSelector::IsReady(Socket& socket) const {
	return FD_ISSET(socket.GetHandle(), &mImpl->SocketsReady) != 0;
}

SocketSelector& SocketSelector::operator =(const SocketSelector& right) {
	SocketSelector temp(right);

	std::swap(mImpl, temp.mImpl);

	return *this;
}

}}
